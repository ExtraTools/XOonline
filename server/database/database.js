import sqlite3 from 'sqlite3';
import bcrypt from 'bcryptjs';
import { randomUUID } from 'crypto';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

let dbPath;
let db;

if (process.env.NODE_ENV === 'production') {
    dbPath = '/tmp/dinosgames.db';
    console.log('üêò –ò—Å–ø–æ–ª—å–∑—É—é SQLite —Ñ–∞–π–ª –¥–ª—è production:', dbPath);
    db = new sqlite3.Database(dbPath, (err) => {
        if (err) {
            console.error('‚ùå –û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è –±–∞–∑—ã –≤ production:', err);
        } else {
            console.log('üü¢ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö production –≥–æ—Ç–æ–≤–∞');
        }
    });
} else {
    dbPath = join(__dirname, '../../data/dinosgames.db');
    db = new sqlite3.Database(dbPath, (err) => {
        if (err) {
            console.error('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–∫—Ä—ã—Ç–∏—è —Ñ–∞–π–ª–∞ –±–∞–∑—ã:', err);
        } else {
            console.log('üü¢ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö —Ñ–∞–π–ª –≥–æ—Ç–æ–≤–∞');
        }
    });
}

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–∞–±–ª–∏—Ü
export const initDatabase = () => {
    return new Promise((resolve, reject) => {
        db.serialize(() => {
            // –¢–∞–±–ª–∏—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
            db.run(`
                CREATE TABLE IF NOT EXISTS users (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    uuid VARCHAR(36) UNIQUE NOT NULL,
                    username VARCHAR(50) UNIQUE NOT NULL,
                    email VARCHAR(100) UNIQUE NOT NULL,
                    password_hash VARCHAR(255) NOT NULL,
                    avatar_url VARCHAR(255) DEFAULT NULL,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    last_login DATETIME DEFAULT NULL,
                    is_online BOOLEAN DEFAULT 0,
                    status VARCHAR(20) DEFAULT 'active'
                )
            `, (err) => {
                if (err) {
                    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–∞–±–ª–∏—Ü—ã users:', err);
                    reject(err);
                    return;
                }
            });

            // –î–æ–±–∞–≤–ª—è–µ–º UUID –ø–æ–ª–µ –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç (—Å–Ω–∞—á–∞–ª–∞ –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è)
            db.run(`
                ALTER TABLE users ADD COLUMN uuid VARCHAR(36)
            `, (err) => {
                // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫—É –µ—Å–ª–∏ –ø–æ–ª–µ —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
                if (err && !err.message.includes('duplicate column name')) {
                    console.error('–û—à–∏–±–∫–∞ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è UUID –ø–æ–ª—è:', err);
                } else {
                    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –±–µ–∑ UUID
                    db.all(`SELECT id FROM users WHERE uuid IS NULL`, (err, rows) => {
                        if (err) {
                            console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –±–µ–∑ UUID:', err);
                            return;
                        }
                        
                        // –û–±–Ω–æ–≤–ª—è–µ–º –∫–∞–∂–¥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è —Å —É–Ω–∏–∫–∞–ª—å–Ω—ã–º UUID
                        const updatePromises = rows.map(row => {
                            return new Promise((resolve, reject) => {
                                db.run(`UPDATE users SET uuid = ? WHERE id = ?`, [randomUUID(), row.id], (err) => {
                                    if (err) {
                                        console.error(`–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è UUID –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è ${row.id}:`, err);
                                        reject(err);
                                    } else {
                                        resolve();
                                    }
                                });
                            });
                        });
                        
                        Promise.all(updatePromises).then(() => {
                            // –°–æ–∑–¥–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π –∏–Ω–¥–µ–∫—Å –ø–æ—Å–ª–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
                            db.run(`CREATE UNIQUE INDEX IF NOT EXISTS idx_users_uuid ON users(uuid)`, (err) => {
                                if (err) {
                                    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —É–Ω–∏–∫–∞–ª—å–Ω–æ–≥–æ –∏–Ω–¥–µ–∫—Å–∞ –¥–ª—è UUID:', err);
                                } else {
                                    console.log('‚úÖ UUID –ø–æ–ª–µ —É—Å–ø–µ—à–Ω–æ –¥–æ–±–∞–≤–ª–µ–Ω–æ –∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ');
                                }
                            });
                        }).catch(err => {
                            console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ UUID:', err);
                        });
                    });
                }
            });

            // –¢–∞–±–ª–∏—Ü–∞ —Å–µ—Å—Å–∏–π
            db.run(`
                CREATE TABLE IF NOT EXISTS sessions (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    token VARCHAR(255) UNIQUE NOT NULL,
                    expires_at DATETIME NOT NULL,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
                )
            `, (err) => {
                if (err) {
                    console.error('–û—à–∏–±–∫–∞ —Å–æ–∑–¥–∞–Ω–∏—è —Ç–∞–±–ª–∏—Ü—ã sessions:', err);
                    reject(err);
                    return;
                }
            });

            // –¢–∞–±–ª–∏—Ü–∞ –ø—Ä–æ—Ñ–∏–ª–µ–π –∏–≥—Ä–æ–∫–æ–≤
            db.run(`
                CREATE TABLE IF NOT EXISTS user_profiles (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER UNIQUE NOT NULL,
                    level INTEGER DEFAULT 1,
                    rating INTEGER DEFAULT 1000,
                    avatar TEXT DEFAULT 'avatars/photo_2025-07-03_02-50-32.jpg',
                    title TEXT DEFAULT '–ò–≥—Ä–æ–∫ XO Online',
                    bio TEXT,
                    total_play_time INTEGER DEFAULT 0,
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
                )
            `);

            // –¢–∞–±–ª–∏—Ü–∞ –∏–≥—Ä–æ–≤–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
            db.run(`
                CREATE TABLE IF NOT EXISTS player_stats (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    total_games INTEGER DEFAULT 0,
                    wins INTEGER DEFAULT 0,
                    losses INTEGER DEFAULT 0,
                    draws INTEGER DEFAULT 0,
                    current_streak INTEGER DEFAULT 0,
                    best_streak INTEGER DEFAULT 0,
                    total_play_time INTEGER DEFAULT 0,
                    avg_game_duration REAL DEFAULT 0,
                    favorite_game_mode TEXT DEFAULT 'XO Classic',
                    rating_history TEXT DEFAULT '[]',
                    last_game_at DATETIME,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
                )
            `);

            // –¢–∞–±–ª–∏—Ü–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
            db.run(`
                CREATE TABLE IF NOT EXISTS achievements (
                    id TEXT PRIMARY KEY,
                    name TEXT NOT NULL,
                    description TEXT NOT NULL,
                    icon TEXT DEFAULT 'üèÜ',
                    category TEXT DEFAULT 'general',
                    points INTEGER DEFAULT 0,
                    hidden BOOLEAN DEFAULT 0
                )
            `);

            // –¢–∞–±–ª–∏—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
            db.run(`
                CREATE TABLE IF NOT EXISTS user_achievements (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    achievement_id TEXT NOT NULL,
                    unlocked_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    progress INTEGER DEFAULT 100,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE,
                    FOREIGN KEY (achievement_id) REFERENCES achievements (id),
                    UNIQUE (user_id, achievement_id)
                )
            `);

            // –¢–∞–±–ª–∏—Ü–∞ –¥—Ä—É–∑–µ–π
            db.run(`
                CREATE TABLE IF NOT EXISTS friendships (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    requester_id INTEGER NOT NULL,
                    addressee_id INTEGER NOT NULL,
                    status TEXT DEFAULT 'pending',
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (requester_id) REFERENCES users (id) ON DELETE CASCADE,
                    FOREIGN KEY (addressee_id) REFERENCES users (id) ON DELETE CASCADE,
                    UNIQUE (requester_id, addressee_id)
                )
            `);

            // –¢–∞–±–ª–∏—Ü–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø—Ä–æ—Ñ–∏–ª—è
            db.run(`
                CREATE TABLE IF NOT EXISTS profile_activity (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER NOT NULL,
                    activity_type TEXT NOT NULL,
                    description TEXT NOT NULL,
                    metadata TEXT DEFAULT '{}',
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (id) ON DELETE CASCADE
                )
            `);

            // –¢–∞–±–ª–∏—Ü–∞ –∏—Å—Ç–æ—Ä–∏–∏ –∏–≥—Ä
            db.run(`
                CREATE TABLE IF NOT EXISTS game_history (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    player1_id INTEGER NOT NULL,
                    player2_id INTEGER,
                    winner_id INTEGER,
                    game_mode TEXT DEFAULT 'classic',
                    duration INTEGER,
                    moves TEXT DEFAULT '[]',
                    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (player1_id) REFERENCES users (id) ON DELETE CASCADE,
                    FOREIGN KEY (player2_id) REFERENCES users (id) ON DELETE CASCADE,
                    FOREIGN KEY (winner_id) REFERENCES users (id) ON DELETE CASCADE
                )
            `);

            // –ó–∞–ø–æ–ª–Ω—è–µ–º –±–∞–∑–æ–≤—ã–µ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è
            const achievements = [
                ['first_game', '–ü–µ—Ä–≤–∞—è –∏–≥—Ä–∞', '–°—ã–≥—Ä–∞–π—Ç–µ —Å–≤–æ—é –ø–µ—Ä–≤—É—é –∏–≥—Ä—É', 'ÔøΩÔøΩ', 'beginner', 10],
                ['first_win', '–ü–µ—Ä–≤–∞—è –ø–æ–±–µ–¥–∞', '–í—ã–∏–≥—Ä–∞–π—Ç–µ —Å–≤–æ—é –ø–µ—Ä–≤—É—é –∏–≥—Ä—É', 'üéØ', 'beginner', 20],
                ['win_streak_5', '–û–≥–Ω–µ–Ω–Ω–∞—è —Å–µ—Ä–∏—è', '–í—ã–∏–≥—Ä–∞–π—Ç–µ 5 –∏–≥—Ä –ø–æ–¥—Ä—è–¥', 'üî•', 'streaks', 50],
                ['win_streak_10', '–ù–µ—É–¥–µ—Ä–∂–∏–º—ã–π', '–í—ã–∏–≥—Ä–∞–π—Ç–µ 10 –∏–≥—Ä –ø–æ–¥—Ä—è–¥', '‚ö°', 'streaks', 100],
                ['wins_10', '–ù–æ–≤–∏—á–æ–∫', '–í—ã–∏–≥—Ä–∞–π—Ç–µ 10 –∏–≥—Ä', 'ü•â', 'wins', 30],
                ['wins_50', '–û–ø—ã—Ç–Ω—ã–π –∏–≥—Ä–æ–∫', '–í—ã–∏–≥—Ä–∞–π—Ç–µ 50 –∏–≥—Ä', 'ü•à', 'wins', 75],
                ['wins_100', '–ú–∞—Å—Ç–µ—Ä XO', '–í—ã–∏–≥—Ä–∞–π—Ç–µ 100 –∏–≥—Ä', 'ü•á', 'wins', 150],
                ['wins_500', '–õ–µ–≥–µ–Ω–¥–∞', '–í—ã–∏–≥—Ä–∞–π—Ç–µ 500 –∏–≥—Ä', 'üëë', 'wins', 500],
                ['high_winrate', '–≠—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω—ã–π', '–ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–π—Ç–µ 70% –ø–æ–±–µ–¥ –≤ 20+ –∏–≥—Ä–∞—Ö', 'üíé', 'special', 100],
                ['speed_demon', '–ú–æ–ª–Ω–∏—è', '–í—ã–∏–≥—Ä–∞–π—Ç–µ –∏–≥—Ä—É –∑–∞ 30 —Å–µ–∫—É–Ω–¥', '‚ö°', 'special', 75],
                ['marathon', '–ú–∞—Ä–∞—Ñ–æ–Ω–µ—Ü', '–°—ã–≥—Ä–∞–π—Ç–µ 8 —á–∞—Å–æ–≤ –ø–æ–¥—Ä—è–¥', 'üèÉ', 'time', 200],
                ['night_owl', '–°–æ–≤–∞', '–°—ã–≥—Ä–∞–π—Ç–µ –∏–≥—Ä—É –≤ 3 —á–∞—Å–∞ –Ω–æ—á–∏', 'ü¶â', 'special', 25],
                ['social_butterfly', '–°–æ—Ü–∏–∞–ª—å–Ω–∞—è –±–∞–±–æ—á–∫–∞', '–î–æ–±–∞–≤—å—Ç–µ 10 –¥—Ä—É–∑–µ–π', 'ü¶ã', 'social', 50],
                ['mentor', '–ù–∞—Å—Ç–∞–≤–Ω–∏–∫', '–ü–æ–º–æ–≥–∏—Ç–µ –Ω–æ–≤–∏—á–∫—É –≤—ã–∏–≥—Ä–∞—Ç—å –ø–µ—Ä–≤—É—é –∏–≥—Ä—É', 'üéì', 'social', 100]
            ];

            const achievementStmt = db.prepare(`
                INSERT OR IGNORE INTO achievements (id, name, description, icon, category, points)
                VALUES (?, ?, ?, ?, ?, ?)
            `);

            achievements.forEach(achievement => {
                achievementStmt.run(achievement);
            });

            achievementStmt.finalize();

            console.log('üü¢ –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–∞ —Å–æ –≤—Å–µ–º–∏ —Ç–∞–±–ª–∏—Ü–∞–º–∏');
            resolve();
        });
    });
};

// –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏
export const userQueries = {
    // –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    create: async (username, email, password) => {
        return new Promise(async (resolve, reject) => {
            try {
                // –•–µ—à–∏—Ä—É–µ–º –ø–∞—Ä–æ–ª—å
                const passwordHash = await bcrypt.hash(password, 12);
                // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º UUID
                const userUuid = randomUUID();
                
                const stmt = db.prepare(`
                    INSERT INTO users (uuid, username, email, password_hash) 
                    VALUES (?, ?, ?, ?)
                `);
                
                stmt.run([userUuid, username, email, passwordHash], function(err) {
                    if (err) {
                        reject(err);
                    } else {
                        resolve({ id: this.lastID, uuid: userUuid, username, email });
                    }
                });
                
                stmt.finalize();
            } catch (err) {
                reject(err);
            }
        });
    },

    // –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ email
    findByEmail: (email) => {
        return new Promise((resolve, reject) => {
            console.log('üîç DB: searching user by email:', email);
            db.get(
                'SELECT * FROM users WHERE email = ?',
                [email],
                (err, row) => {
                    if (err) {
                        console.log('‚ùå DB error in findByEmail:', err);
                        reject(err);
                    } else {
                        console.log('üíæ DB result:', row ? 'found' : 'not found');
                        resolve(row);
                    }
                }
            );
        });
    },

    // –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ ID
    findById: (id) => {
        return new Promise((resolve, reject) => {
            db.get(
                'SELECT id, uuid, username, email, avatar_url, created_at, last_login FROM users WHERE id = ?',
                [id],
                (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                }
            );
        });
    },

    // –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ username
    findByUsername: (username) => {
        return new Promise((resolve, reject) => {
            console.log('üîç DB: searching user by username:', username);
            db.get(
                'SELECT * FROM users WHERE username = ?',
                [username],
                (err, row) => {
                    if (err) {
                        console.log('‚ùå DB error in findByUsername:', err);
                        reject(err);
                    } else {
                        console.log('üíæ DB result:', row ? 'found' : 'not found');
                        resolve(row);
                    }
                }
            );
        });
    },

    // –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ –ª–æ–≥–∏–Ω—É (email –∏–ª–∏ username)
    findByLogin: (login) => {
        return new Promise((resolve, reject) => {
            console.log('üîç DB: searching user by login:', login);
            db.get(
                'SELECT * FROM users WHERE email = ? OR username = ?',
                [login, login],
                (err, row) => {
                    if (err) {
                        console.log('‚ùå DB error in findByLogin:', err);
                        reject(err);
                    } else {
                        console.log('üíæ DB result:', row ? 'found' : 'not found');
                        resolve(row);
                    }
                }
            );
        });
    },

    // –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ UUID
    findByUuid: (uuid) => {
        return new Promise((resolve, reject) => {
            console.log('üîç DB: searching user by UUID:', uuid);
            db.get(
                'SELECT id, uuid, username, email, avatar_url, created_at, last_login, is_online, status FROM users WHERE uuid = ?',
                [uuid],
                (err, row) => {
                    if (err) {
                        console.log('‚ùå DB error in findByUuid:', err);
                        reject(err);
                    } else {
                        console.log('üíæ DB result:', row ? 'found' : 'not found');
                        resolve(row);
                    }
                }
            );
        });
    },

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –æ–Ω–ª–∞–π–Ω
    updateOnlineStatus: (userId, isOnline) => {
        return new Promise((resolve, reject) => {
            const query = isOnline 
                ? 'UPDATE users SET is_online = 1, last_login = CURRENT_TIMESTAMP WHERE id = ?'
                : 'UPDATE users SET is_online = 0 WHERE id = ?';
                
            db.run(query, [userId], (err) => {
                if (err) reject(err);
                else resolve();
            });
        });
    },

    getOnlineUsers: () => {
        return new Promise((resolve, reject) => {
            db.all(
                'SELECT id, uuid, username, avatar_url FROM users WHERE is_online = 1 ORDER BY username',
                [],
                (err, rows) => {
                    if (err) reject(err);
                    else resolve(rows);
                }
            );
        });
    },

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–∞—Ä–æ–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    updatePassword: (userId, newPasswordHash) => {
        return new Promise((resolve, reject) => {
            db.run(
                'UPDATE users SET password_hash = ? WHERE id = ?',
                [newPasswordHash, userId],
                (err) => {
                    if (err) reject(err);
                    else resolve();
                }
            );
        });
    },

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–≤–∞—Ç–∞—Ä–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    updateAvatar: (userId, avatarUrl) => {
        return new Promise((resolve, reject) => {
            db.run(
                'UPDATE users SET avatar_url = ? WHERE id = ?',
                [avatarUrl, userId],
                (err) => {
                    if (err) reject(err);
                    else resolve();
                }
            );
        });
    }
};

// –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å —Å–µ—Å—Å–∏—è–º–∏
export const sessionQueries = {
    // –°–æ–∑–¥–∞–Ω–∏–µ —Å–µ—Å—Å–∏–∏
    create: (userId, token, expiresAt) => {
        return new Promise((resolve, reject) => {
            const stmt = db.prepare(`
                INSERT INTO sessions (user_id, token, expires_at) 
                VALUES (?, ?, ?)
            `);
            
            stmt.run([userId, token, expiresAt], function(err) {
                if (err) reject(err);
                else resolve({ id: this.lastID, user_id: userId, token });
            });
            
            stmt.finalize();
        });
    },

    // –ü–æ–∏—Å–∫ —Å–µ—Å—Å–∏–∏ –ø–æ —Ç–æ–∫–µ–Ω—É
    findByToken: (token) => {
        return new Promise((resolve, reject) => {
            db.get(
                'SELECT * FROM sessions WHERE token = ? AND expires_at > CURRENT_TIMESTAMP',
                [token],
                (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                }
            );
        });
    },

    // –£–¥–∞–ª–µ–Ω–∏–µ —Å–µ—Å—Å–∏–∏
    delete: (token) => {
        return new Promise((resolve, reject) => {
            db.run(
                'DELETE FROM sessions WHERE token = ?',
                [token],
                (err) => {
                    if (err) reject(err);
                    else resolve();
                }
            );
        });
    },

    // –û—á–∏—Å—Ç–∫–∞ –∏—Å—Ç–µ–∫—à–∏—Ö —Å–µ—Å—Å–∏–π
    cleanup: () => {
        return new Promise((resolve, reject) => {
            db.run(
                'DELETE FROM sessions WHERE expires_at <= CURRENT_TIMESTAMP',
                [],
                (err) => {
                    if (err) reject(err);
                    else resolve();
                }
            );
        });
    }
};

// –ó–∞–ø—Ä–æ—Å—ã –¥–ª—è –ø—Ä–æ—Ñ–∏–ª–µ–π
export const profileQueries = {
    // –°–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è
    createProfile: (userId, data = {}) => {
        return new Promise((resolve, reject) => {
            const {
                level = 1,
                rating = 1000,
                avatar = 'avatars/photo_2025-07-03_02-50-32.jpg',
                title = '–ò–≥—Ä–æ–∫ XO Online'
            } = data;

            const stmt = db.prepare(`
                INSERT INTO user_profiles (user_id, level, rating, avatar, title)
                VALUES (?, ?, ?, ?, ?)
            `);

            stmt.run([userId, level, rating, avatar, title], function(err) {
                if (err) {
                    reject(err);
                } else {
                    // –°–æ–∑–¥–∞–µ–º —Ç–∞–∫–∂–µ –∑–∞–ø–∏—Å—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
                    statsQueries.createStats(userId).then(() => {
                        resolve(this.lastID);
                    }).catch(reject);
                }
            });

            stmt.finalize();
        });
    },

    // –ü–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è
    getProfile: (userId) => {
        return new Promise((resolve, reject) => {
            db.get(`
                SELECT 
                    u.*,
                    p.level,
                    p.rating,
                    p.avatar,
                    p.title,
                    p.bio,
                    p.total_play_time
                FROM users u
                LEFT JOIN user_profiles p ON u.id = p.user_id
                WHERE u.id = ?
            `, [userId], (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });
    },

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–≤–∞—Ç–∞—Ä–∞
    updateAvatar: (userId, avatar) => {
        return new Promise((resolve, reject) => {
            db.run(
                'UPDATE user_profiles SET avatar = ?, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?',
                [avatar, userId],
                (err) => {
                    if (err) reject(err);
                    else resolve();
                }
            );
        });
    },

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–µ–π—Ç–∏–Ω–≥–∞
    updateRating: (userId, change) => {
        return new Promise((resolve, reject) => {
            db.get(
                'SELECT rating FROM user_profiles WHERE user_id = ?',
                [userId],
                (err, row) => {
                    if (err) {
                        reject(err);
                        return;
                    }

                    const newRating = Math.max(0, (row?.rating || 1000) + change);
                    
                    db.run(
                        'UPDATE user_profiles SET rating = ?, updated_at = CURRENT_TIMESTAMP WHERE user_id = ?',
                        [newRating, userId],
                        (err) => {
                            if (err) reject(err);
                            else resolve(newRating);
                        }
                    );
                }
            );
        });
    },

    // –ü–æ–∏—Å–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ –∏–º–µ–Ω–∏
    findUserByName: (username) => {
        return new Promise((resolve, reject) => {
            db.get(
                'SELECT id, username, email FROM users WHERE username = ?',
                [username],
                (err, row) => {
                    if (err) reject(err);
                    else resolve(row);
                }
            );
        });
    },

    // –ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ–ø–∞ –∏–≥—Ä–æ–∫–æ–≤
    getLeaderboard: (limit = 10, offset = 0) => {
        return new Promise((resolve, reject) => {
            db.all(`
                SELECT 
                    u.username,
                    p.level,
                    p.rating,
                    p.avatar,
                    s.wins,
                    s.total_games
                FROM users u
                JOIN user_profiles p ON u.id = p.user_id
                LEFT JOIN player_stats s ON u.id = s.user_id
                ORDER BY p.rating DESC
                LIMIT ? OFFSET ?
            `, [limit, offset], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    },

    // –ü–æ–∏—Å–∫ –∏–≥—Ä–æ–∫–æ–≤
    searchPlayers: (query) => {
        return new Promise((resolve, reject) => {
            db.all(`
                SELECT 
                    u.id,
                    u.username,
                    p.level,
                    p.rating,
                    p.avatar
                FROM users u
                LEFT JOIN user_profiles p ON u.id = p.user_id
                WHERE u.username LIKE ?
                LIMIT 20
            `, [`%${query}%`], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    },

    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
    addActivity: (userId, type, description, metadata = '{}') => {
        return new Promise((resolve, reject) => {
            const stmt = db.prepare(`
                INSERT INTO profile_activity (user_id, activity_type, description, metadata)
                VALUES (?, ?, ?, ?)
            `);

            stmt.run([userId, type, description, metadata], function(err) {
                if (err) reject(err);
                else resolve(this.lastID);
            });

            stmt.finalize();
        });
    },

    // –ü–æ–ª—É—á–µ–Ω–∏–µ –Ω–µ–¥–∞–≤–Ω–µ–π –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
    getRecentActivity: (userId, limit = 10) => {
        return new Promise((resolve, reject) => {
            db.all(`
                SELECT * FROM profile_activity
                WHERE user_id = ?
                ORDER BY created_at DESC
                LIMIT ?
            `, [userId, limit], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    }
};

// –ó–∞–ø—Ä–æ—Å—ã –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
export const statsQueries = {
    // –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞–ø–∏—Å–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    createStats: (userId) => {
        return new Promise((resolve, reject) => {
            const stmt = db.prepare(`
                INSERT INTO player_stats (user_id)
                VALUES (?)
            `);

            stmt.run([userId], function(err) {
                if (err) reject(err);
                else resolve(this.lastID);
            });

            stmt.finalize();
        });
    },

    // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –∏–≥—Ä–æ–∫–∞
    getPlayerStats: (userId) => {
        return new Promise((resolve, reject) => {
            db.get(`
                SELECT * FROM player_stats WHERE user_id = ?
            `, [userId], (err, row) => {
                if (err) {
                    reject(err);
                } else if (!row) {
                    // –°–æ–∑–¥–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –µ—Å–ª–∏ –µ—ë –Ω–µ—Ç
                    this.createStats(userId).then(() => {
                        this.getPlayerStats(userId).then(resolve).catch(reject);
                    }).catch(reject);
                } else {
                    // –í—ã—á–∏—Å–ª—è–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–æ–ª—è
                    const winRate = row.total_games > 0 ? 
                        ((row.wins / row.total_games) * 100).toFixed(1) : 0;
                    
                    resolve({
                        ...row,
                        winRate: parseFloat(winRate)
                    });
                }
            });
        });
    },

    // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ—Å–ª–µ –∏–≥—Ä—ã
    updateGameStats: (userId, gameData) => {
        return new Promise((resolve, reject) => {
            const { result, gameMode, duration = 0 } = gameData;

            db.get('SELECT * FROM player_stats WHERE user_id = ?', [userId], (err, stats) => {
                if (err) {
                    reject(err);
                    return;
                }

                if (!stats) {
                    this.createStats(userId).then(() => {
                        this.updateGameStats(userId, gameData).then(resolve).catch(reject);
                    }).catch(reject);
                    return;
                }

                const updates = {
                    total_games: stats.total_games + 1,
                    wins: stats.wins + (result === 'win' ? 1 : 0),
                    losses: stats.losses + (result === 'loss' ? 1 : 0),
                    draws: stats.draws + (result === 'draw' ? 1 : 0),
                    total_play_time: stats.total_play_time + duration,
                    current_streak: result === 'win' ? stats.current_streak + 1 : 0,
                    best_streak: result === 'win' ? 
                        Math.max(stats.best_streak, stats.current_streak + 1) : 
                        stats.best_streak,
                    favorite_game_mode: gameMode || stats.favorite_game_mode,
                    last_game_at: new Date().toISOString()
                };

                // –í—ã—á–∏—Å–ª—è–µ–º —Å—Ä–µ–¥–Ω—é—é –ø—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –∏–≥—Ä—ã
                if (updates.total_games > 0) {
                    updates.avg_game_duration = updates.total_play_time / updates.total_games;
                }

                const stmt = db.prepare(`
                    UPDATE player_stats SET
                        total_games = ?,
                        wins = ?,
                        losses = ?,
                        draws = ?,
                        current_streak = ?,
                        best_streak = ?,
                        total_play_time = ?,
                        avg_game_duration = ?,
                        favorite_game_mode = ?,
                        last_game_at = ?,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE user_id = ?
                `);

                stmt.run([
                    updates.total_games,
                    updates.wins,
                    updates.losses,
                    updates.draws,
                    updates.current_streak,
                    updates.best_streak,
                    updates.total_play_time,
                    updates.avg_game_duration,
                    updates.favorite_game_mode,
                    updates.last_game_at,
                    userId
                ], (err) => {
                    if (err) reject(err);
                    else resolve(updates);
                });

                stmt.finalize();
            });
        });
    }
};

// –ó–∞–ø—Ä–æ—Å—ã –¥–ª—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
export const achievementQueries = {
    // –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    getUserAchievements: (userId) => {
        return new Promise((resolve, reject) => {
            db.all(`
                SELECT 
                    a.*,
                    ua.unlocked_at,
                    ua.progress,
                    CASE WHEN ua.user_id IS NOT NULL THEN 1 ELSE 0 END as unlocked
                FROM achievements a
                LEFT JOIN user_achievements ua ON a.id = ua.achievement_id AND ua.user_id = ?
                ORDER BY unlocked DESC, a.category, a.points
            `, [userId], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    },

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞–ª–∏—á–∏—è –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è
    hasAchievement: (userId, achievementId) => {
        return new Promise((resolve, reject) => {
            db.get(`
                SELECT 1 FROM user_achievements 
                WHERE user_id = ? AND achievement_id = ?
            `, [userId, achievementId], (err, row) => {
                if (err) reject(err);
                else resolve(!!row);
            });
        });
    },

    // –†–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∫–∞ –¥–æ—Å—Ç–∏–∂–µ–Ω–∏—è
    unlockAchievement: (userId, achievementId, progress = 100) => {
        return new Promise((resolve, reject) => {
            const stmt = db.prepare(`
                INSERT OR IGNORE INTO user_achievements (user_id, achievement_id, progress)
                VALUES (?, ?, ?)
            `);

            stmt.run([userId, achievementId, progress], function(err) {
                if (err) reject(err);
                else resolve(this.changes > 0);
            });

            stmt.finalize();
        });
    }
};

// –ó–∞–ø—Ä–æ—Å—ã –¥–ª—è –¥—Ä—É–∑–µ–π
export const friendsQueries = {
    // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥—Ä—É–∑–µ–π
    getFriendsList: (userId) => {
        return new Promise((resolve, reject) => {
            db.all(`
                SELECT 
                    u.id,
                    u.username,
                    u.is_online,
                    u.last_login,
                    p.avatar,
                    p.level,
                    p.rating,
                    f.status,
                    f.created_at as friend_since
                FROM friendships f
                JOIN users u ON (
                    CASE 
                        WHEN f.requester_id = ? THEN u.id = f.addressee_id
                        ELSE u.id = f.requester_id
                    END
                )
                LEFT JOIN user_profiles p ON u.id = p.user_id
                WHERE (f.requester_id = ? OR f.addressee_id = ?) 
                AND f.status = 'accepted'
                ORDER BY u.is_online DESC, u.last_login DESC
            `, [userId, userId, userId], (err, rows) => {
                if (err) reject(err);
                else resolve(rows);
            });
        });
    },

    // –ü—Ä–æ–≤–µ—Ä–∫–∞ –¥—Ä—É–∂–±—ã
    checkFriendship: (userId, friendId) => {
        return new Promise((resolve, reject) => {
            db.get(`
                SELECT * FROM friendships 
                WHERE (requester_id = ? AND addressee_id = ?) 
                OR (requester_id = ? AND addressee_id = ?)
            `, [userId, friendId, friendId, userId], (err, row) => {
                if (err) reject(err);
                else resolve(row);
            });
        });
    },

    // –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –¥—Ä—É–≥–∞
    addFriend: (userId, friendId) => {
        return new Promise((resolve, reject) => {
            const stmt = db.prepare(`
                INSERT INTO friendships (requester_id, addressee_id, status)
                VALUES (?, ?, 'pending')
            `);

            stmt.run([userId, friendId], function(err) {
                if (err) reject(err);
                else resolve(this.lastID);
            });

            stmt.finalize();
        });
    },

    // –ü—Ä–∏–Ω—è—Ç–∏–µ –∑–∞–ø—Ä–æ—Å–∞ –≤ –¥—Ä—É–∑—å—è
    acceptFriendRequest: (userId, friendId) => {
        return new Promise((resolve, reject) => {
            db.run(`
                UPDATE friendships 
                SET status = 'accepted', updated_at = CURRENT_TIMESTAMP
                WHERE addressee_id = ? AND requester_id = ? AND status = 'pending'
            `, [userId, friendId], (err) => {
                if (err) reject(err);
                else resolve();
            });
        });
    },

    // –£–¥–∞–ª–µ–Ω–∏–µ –¥—Ä—É–≥–∞
    removeFriend: (userId, friendId) => {
        return new Promise((resolve, reject) => {
            db.run(`
                DELETE FROM friendships 
                WHERE (requester_id = ? AND addressee_id = ?) 
                OR (requester_id = ? AND addressee_id = ?)
            `, [userId, friendId, friendId, userId], (err) => {
                if (err) reject(err);
                else resolve();
            });
        });
    }
};

export default db; 