import express from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import { body, validationResult } from 'express-validator';
import { userQueries, refreshTokenQueries } from '../database/database.js';

const router = express.Router();

// –ö–æ–Ω—Å—Ç–∞–Ω—Ç—ã
const JWT_SECRET = process.env.JWT_SECRET || 'dino-secret-key';
const SALT_ROUNDS = 12;
const ACCESS_TOKEN_EXPIRES_IN = '15m';
const REFRESH_TOKEN_EXPIRES_DAYS = 7;

// Middleware –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏–∏
export const authenticateToken = async (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

    if (!token) {
        return res.status(401).json({ 
            success: false, 
            message: '–¢–æ–∫–µ–Ω –¥–æ—Å—Ç—É–ø–∞ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω' 
        });
    }

    try {
        // –í–µ—Ä–∏—Ñ–∏—Ü–∏—Ä—É–µ–º JWT access token
        const decoded = jwt.verify(token, JWT_SECRET);
        const user = await userQueries.findById(decoded.userId);

        if (!user) {
            return res.status(403).json({ success: false, message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' });
        }

        req.user = user;
        next();
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–æ–∫–µ–Ω–∞:', error);
        return res.status(403).json({ success: false, message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' });
    }
};

// –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
const registerValidation = [
    body('username')
        .isLength({ min: 3, max: 20 })
        .withMessage('–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 3 –¥–æ 20 —Å–∏–º–≤–æ–ª–æ–≤')
        .matches(/^[a-zA-Z0-9_]+$/)
        .withMessage('–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã, —Ü–∏—Ñ—Ä—ã –∏ –ø–æ–¥—á–µ—Ä–∫–∏–≤–∞–Ω–∏—è'),
    
    body('email')
        .isEmail()
        .withMessage('–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π email')
        .normalizeEmail(),
    
    body('password')
        .isLength({ min: 1 })
        .withMessage('–ü–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω')
];

// –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–ª—è –≤—Ö–æ–¥–∞
const loginValidation = [
    body('login')
        .notEmpty()
        .withMessage('–í–≤–µ–¥–∏—Ç–µ email –∏–ª–∏ –Ω–∏–∫–Ω–µ–π–º'),
    
    body('password')
        .notEmpty()
        .withMessage('–ü–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω')
];

// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫—Ä–∏–ø—Ç–æ—Å—Ç–æ–π–∫–æ–≥–æ refresh —Ç–æ–∫–µ–Ω–∞
const generateRefreshToken = () => crypto.randomBytes(64).toString('hex');

// –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
router.post('/register', registerValidation, async (req, res) => {
    try {
        console.log('üìù Register attempt:', req.body);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–∞—Ü–∏—é
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            console.log('‚ùå Register validation errors:', errors.array());
            return res.status(400).json({
                success: false,
                message: '–û—à–∏–±–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏',
                errors: errors.array()
            });
        }

        const { username, email, password } = req.body;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å email
        const existingUserByEmail = await userQueries.findByEmail(email);
        if (existingUserByEmail) {
            return res.status(400).json({
                success: false,
                message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'
            });
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å username
        const existingUserByUsername = await userQueries.findByUsername(username);
        if (existingUserByUsername) {
            return res.status(400).json({
                success: false,
                message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'
            });
        }

        // –°–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–ø–∞—Ä–æ–ª—å –±—É–¥–µ—Ç –∑–∞—Ö–µ—à–∏—Ä–æ–≤–∞–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤ –º–æ–¥–µ–ª–∏)
        const user = await userQueries.create(username, email, password);

        // –°–æ–∑–¥–∞–µ–º access –∏ refresh —Ç–æ–∫–µ–Ω—ã
        const accessToken = jwt.sign(
            { userId: user.id, username: user.username },
            JWT_SECRET,
            { expiresIn: ACCESS_TOKEN_EXPIRES_IN }
        );

        const refreshToken = generateRefreshToken();
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + REFRESH_TOKEN_EXPIRES_DAYS);
        await refreshTokenQueries.create(user.id, refreshToken, expiresAt.toISOString());

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –æ–Ω–ª–∞–π–Ω
        await userQueries.updateOnlineStatus(user.id, true);

        res.status(201).json({
            success: true,
            message: '–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞',
            user: {
                id: user.id,
                username: user.username,
                email: user.email
            },
            accessToken,
            refreshToken
        });

    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:', error);
        res.status(500).json({
            success: false,
            message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'
        });
    }
});

// –í—Ö–æ–¥
router.post('/login', loginValidation, async (req, res) => {
    try {
        console.log('üîê Login attempt:', req.body);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–∞—Ü–∏—é
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            console.log('‚ùå Validation errors:', errors.array());
            return res.status(400).json({
                success: false,
                message: '–û—à–∏–±–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏',
                errors: errors.array()
            });
        }

        const { login, password } = req.body;
        console.log('üîç Looking for user:', login);
        console.log('üîç Input password:', password);

        // –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ email –∏–ª–∏ username
        let user = await userQueries.findByEmail(login);
        if (!user) {
            user = await userQueries.findByUsername(login);
        }
        
        if (!user) {
            console.log('‚ùå User not found:', login);
            return res.status(400).json({
                success: false,
                message: '–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å'
            });
        }
        
        console.log('üü¢ User found:', user.username);
        console.log('üîë Password hash from DB:', user.password_hash ? 'exists' : 'missing');
        console.log('üîç Hash length:', user.password_hash ? user.password_hash.length : 'null');

        // –í–†–ï–ú–ï–ù–ù–ê–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê - —Å–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–π —Ö–µ—à
        const testHash = await bcrypt.hash(password, 12);
        console.log('üß™ Test hash for current password:', testHash);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞—Ä–æ–ª—å
        console.log('üîç Input password length:', password.length);
        console.log('üîç Stored hash length:', user.password_hash ? user.password_hash.length : 'null');
        
        const isPasswordValid = await bcrypt.compare(password, user.password_hash);
        console.log('üîê Password validation result:', isPasswordValid);
        
        // –í–†–ï–ú–ï–ù–ù–ê–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê - –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä—è–º–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ
        if (!isPasswordValid) {
            console.log('‚ùå Password validation failed for user:', user.username);
            console.log('‚ùå Input password:', password);
            console.log('‚ùå Hash from DB:', user.password_hash);
            
            // –í–†–ï–ú–ï–ù–ù–û–ï –†–ï–®–ï–ù–ò–ï: –µ—Å–ª–∏ –ø–∞—Ä–æ–ª—å —Ä–∞–≤–µ–Ω –ø—Ä–æ—Å—Ç–æ–º—É —Ç–µ–∫—Å—Ç—É
            if (password === user.password_hash) {
                console.log('üö® FOUND ISSUE: Password stored as plain text!');
                console.log('üîß Fixing by updating hash...');
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞—Ä–æ–ª—å —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —Ö–µ—à–µ–º
                const newHash = await bcrypt.hash(password, 12);
                await userQueries.updatePassword(user.id, newHash);
                console.log('‚úÖ Password hash updated');
            } else {
                return res.status(400).json({
                    success: false,
                    message: '–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å'
                });
            }
        }

        // –°–æ–∑–¥–∞–µ–º access –∏ refresh —Ç–æ–∫–µ–Ω—ã
        const accessToken = jwt.sign(
            { userId: user.id, username: user.username },
            JWT_SECRET,
            { expiresIn: ACCESS_TOKEN_EXPIRES_IN }
        );

        const refreshToken = generateRefreshToken();
        const rtExpiresAt = new Date();
        rtExpiresAt.setDate(rtExpiresAt.getDate() + REFRESH_TOKEN_EXPIRES_DAYS);
        await refreshTokenQueries.create(user.id, refreshToken, rtExpiresAt.toISOString());

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –æ–Ω–ª–∞–π–Ω
        await userQueries.updateOnlineStatus(user.id, true);

        res.json({
            success: true,
            message: '–í—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ',
            user: {
                id: user.id,
                username: user.username,
                email: user.email,
                rating: user.rating,
                total_games: user.total_games,
                wins: user.wins,
                losses: user.losses,
                draws: user.draws
            },
            accessToken,
            refreshToken
        });

    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞:', error);
        res.status(500).json({
            success: false,
            message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'
        });
    }
});

// –í—ã—Ö–æ–¥
router.post('/logout', authenticateToken, async (req, res) => {
    try {
        const { refreshToken } = req.body;
        if (refreshToken) {
            await refreshTokenQueries.revoke(refreshToken);
        }
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –æ—Ñ—Ñ–ª–∞–π–Ω
        await userQueries.updateOnlineStatus(req.user.id, false);

        res.json({
            success: true,
            message: '–í—ã—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ'
        });

    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –≤—ã—Ö–æ–¥–∞:', error);
        res.status(500).json({
            success: false,
            message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'
        });
    }
});

// –ü–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è —Ç–µ–∫—É—â–µ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
router.get('/profile', authenticateToken, async (req, res) => {
    try {
        const user = await userQueries.findById(req.user.id);
        
        res.json({
            success: true,
            user: {
                id: user.id,
                username: user.username,
                email: user.email,
                avatar_url: user.avatar_url,
                created_at: user.created_at,
                last_login: user.last_login,
                total_games: user.total_games,
                wins: user.wins,
                losses: user.losses,
                draws: user.draws,
                rating: user.rating
            }
        });

    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è:', error);
        res.status(500).json({
            success: false,
            message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'
        });
    }
});

// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞
router.get('/verify', authenticateToken, (req, res) => {
    res.json({
        success: true,
        message: '–¢–æ–∫–µ–Ω –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω',
        user: {
            id: req.user.id,
            username: req.user.username,
            email: req.user.email
        }
    });
});

// –í–†–ï–ú–ï–ù–ù–´–ô –ú–ê–†–®–†–£–¢ –î–õ–Ø –û–¢–õ–ê–î–ö–ò - —É–¥–∞–ª–∏—Ç—å –ø–æ–∑–∂–µ (–æ—Å—Ç–∞–≤–ª—è–µ–º, –Ω–æ –ø–æ–¥ —É—Å–ª–æ–≤–∏–µ–º ENV)
if (process.env.NODE_ENV !== 'production') {
router.post('/debug-login', async (req, res) => {
    try {
        const { login, password } = req.body;
        console.log('üêõ DEBUG LOGIN:', { login, password });
        
        // –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        let user = await userQueries.findByEmail(login);
        if (!user) {
            user = await userQueries.findByUsername(login);
        }
        
        if (!user) {
            return res.json({ success: false, message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω', debug: true });
        }
        
        console.log('üêõ DEBUG USER:', {
            id: user.id,
            username: user.username,
            email: user.email,
            hasHash: !!user.password_hash,
            hashLength: user.password_hash?.length,
            hashStart: user.password_hash?.substring(0, 10) + '...'
        });
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–Ω—ã–µ –≤–∞—Ä–∏–∞–Ω—Ç—ã
        const directMatch = password === user.password_hash;
        const bcryptMatch = await bcrypt.compare(password, user.password_hash);
        
        console.log('üêõ DEBUG CHECKS:', { directMatch, bcryptMatch });
        
        res.json({
            success: false,
            debug: true,
            info: {
                userFound: true,
                username: user.username,
                hasHash: !!user.password_hash,
                hashLength: user.password_hash?.length,
                directMatch,
                bcryptMatch,
                inputLength: password.length
            }
        });
        
    } catch (error) {
        console.error('üêõ DEBUG ERROR:', error);
        res.json({ success: false, error: error.message, debug: true });
    }
});
}

// Endpoint –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è access —Ç–æ–∫–µ–Ω–∞
router.post('/refresh', async (req, res) => {
    try {
        const { refreshToken } = req.body;
        if (!refreshToken) {
            return res.status(400).json({ success: false, message: 'Refresh —Ç–æ–∫–µ–Ω –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω' });
        }

        const stored = await refreshTokenQueries.findByToken(refreshToken);
        if (!stored) {
            return res.status(403).json({ success: false, message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' });
        }

        const user = await userQueries.findById(stored.user_id);
        if (!user) {
            return res.status(404).json({ success: false, message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' });
        }

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –Ω–æ–≤—ã–π access —Ç–æ–∫–µ–Ω
        const newAccess = jwt.sign(
            { userId: user.id, username: user.username },
            JWT_SECRET,
            { expiresIn: ACCESS_TOKEN_EXPIRES_IN }
        );

        res.json({ success: true, accessToken: newAccess });
    } catch (err) {
        console.error('–û—à–∏–±–∫–∞ refresh:', err);
        res.status(500).json({ success: false, message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞' });
    }
});

export default router; 