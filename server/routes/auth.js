import express from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { body, validationResult } from 'express-validator';
import { 
    userQueries, 
    sessionQueries,
    profileQueries
} from '../database/database.js';
import { authenticateToken } from '../middleware/auth.js';

const router = express.Router();

const JWT_SECRET = process.env.JWT_SECRET || 'dino-secret-key';
const SALT_ROUNDS = 12;
const TOKEN_EXPIRES_IN = '7d';

// –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
const registerValidation = [
    body('username')
        .isLength({ min: 3, max: 20 })
        .withMessage('–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 3 –¥–æ 20 —Å–∏–º–≤–æ–ª–æ–≤')
        .matches(/^[a-zA-Z0-9_]+$/)
        .withMessage('–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã, —Ü–∏—Ñ—Ä—ã –∏ –ø–æ–¥—á–µ—Ä–∫–∏–≤–∞–Ω–∏—è'),
    
    body('email')
        .isEmail()
        .withMessage('–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π email')
        .normalizeEmail(),
    
    body('password')
        .isLength({ min: 1 })
        .withMessage('–ü–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω')
];

// –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–ª—è –≤—Ö–æ–¥–∞
const loginValidation = [
    body('login')
        .notEmpty()
        .withMessage('–í–≤–µ–¥–∏—Ç–µ email –∏–ª–∏ –Ω–∏–∫–Ω–µ–π–º'),
    
    body('password')
        .notEmpty()
        .withMessage('–ü–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω')
];

// –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
router.post('/register', registerValidation, async (req, res) => {
    try {
        console.log('üìù Register attempt:', req.body);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–∞—Ü–∏—é
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            console.log('‚ùå Register validation errors:', errors.array());
            return res.status(400).json({
                success: false,
                message: '–û—à–∏–±–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏',
                errors: errors.array()
            });
        }

        const { username, email, password } = req.body;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å email
        const existingUserByEmail = await userQueries.findByEmail(email);
        if (existingUserByEmail) {
            return res.status(400).json({
                success: false,
                message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'
            });
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å username
        const existingUserByUsername = await userQueries.findByUsername(username);
        if (existingUserByUsername) {
            return res.status(400).json({
                success: false,
                message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'
            });
        }

        // –°–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–ø–∞—Ä–æ–ª—å –±—É–¥–µ—Ç –∑–∞—Ö–µ—à–∏—Ä–æ–≤–∞–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤ –º–æ–¥–µ–ª–∏)
        const user = await userQueries.create(username, email, password);

        // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Ñ–∏–ª—å –¥–ª—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await profileQueries.createProfile(user.id, {
            level: 1,
            rating: 1000,
            avatar: 'avatars/default.svg',
            title: '–ù–æ–≤–∏—á–æ–∫ XO Online'
        });

        // –°–æ–∑–¥–∞–µ–º JWT —Ç–æ–∫–µ–Ω
        const token = jwt.sign(
            { id: user.id, username: user.username },
            JWT_SECRET,
            { expiresIn: TOKEN_EXPIRES_IN }
        );

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–µ—Å—Å–∏—é –≤ –±–∞–∑–µ
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + 7); // 7 –¥–Ω–µ–π
        await sessionQueries.create(user.id, token, expiresAt.toISOString());

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –æ–Ω–ª–∞–π–Ω
        await userQueries.updateOnlineStatus(user.id, true);

        res.status(201).json({
            success: true,
            message: '–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞',
            user: {
                id: user.id,
                username: user.username,
                email: user.email
            },
            token
        });

    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:', error);
        res.status(500).json({
            success: false,
            message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'
        });
    }
});

// –í—Ö–æ–¥
router.post('/login', loginValidation, async (req, res) => {
    try {
        console.log('üîê Login attempt:', req.body);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–∞—Ü–∏—é
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            console.log('‚ùå Validation errors:', errors.array());
            return res.status(400).json({
                success: false,
                message: '–û—à–∏–±–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏',
                errors: errors.array()
            });
        }

        const { login, password } = req.body;
        console.log('üîç Looking for user:', login);
        console.log('üîç Input password:', password);

        // –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ email –∏–ª–∏ username
        let user = await userQueries.findByEmail(login);
        if (!user) {
            user = await userQueries.findByUsername(login);
        }
        
        if (!user) {
            console.log('‚ùå User not found:', login);
            return res.status(400).json({
                success: false,
                message: '–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å'
            });
        }
        
        console.log('üü¢ User found:', user.username);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞—Ä–æ–ª—å
        const isPasswordValid = await bcrypt.compare(password, user.password_hash);
        
        if (!isPasswordValid) {
            console.log('‚ùå Password validation failed for user:', user.username);
            return res.status(400).json({
                success: false,
                message: '–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å'
            });
        }

        // –°–æ–∑–¥–∞–µ–º JWT —Ç–æ–∫–µ–Ω
        const token = jwt.sign(
            { id: user.id, username: user.username },
            JWT_SECRET,
            { expiresIn: TOKEN_EXPIRES_IN }
        );

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–µ—Å—Å–∏—é –≤ –±–∞–∑–µ
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + 7); // 7 –¥–Ω–µ–π
        await sessionQueries.create(user.id, token, expiresAt.toISOString());

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –æ–Ω–ª–∞–π–Ω
        await userQueries.updateOnlineStatus(user.id, true);

        res.json({
            success: true,
            message: '–í—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ',
            user: {
                id: user.id,
                username: user.username,
                email: user.email,
            },
            token
        });

    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞:', error);
        res.status(500).json({
            success: false,
            message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'
        });
    }
});

// –í—ã—Ö–æ–¥
router.post('/logout', authenticateToken, async (req, res) => {
    try {
        const authHeader = req.headers['authorization'];
        const token = authHeader && authHeader.split(' ')[1];

        // –£–¥–∞–ª—è–µ–º —Å–µ—Å—Å–∏—é –∏–∑ –±–∞–∑—ã
        await sessionQueries.delete(token);
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –æ—Ñ—Ñ–ª–∞–π–Ω
        await userQueries.updateOnlineStatus(req.user.id, false);

        res.json({
            success: true,
            message: '–í—ã—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ'
        });

    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –≤—ã—Ö–æ–¥–∞:', error);
        res.status(500).json({
            success: false,
            message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'
        });
    }
});

router.get('/profile', authenticateToken, async (req, res) => {
    try {
        const user = await userQueries.getFullUserInfo(req.user.id);
        
        if (!user) {
            return res.status(404).json({ success: false, message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' });
        }
        
        res.json({
            success: true,
            user: {
                id: user.id,
                username: user.username,
                email: user.email,
                avatar_url: user.avatar_url,
                created_at: user.created_at,
                last_login: user.last_login,
                minecraft: {
                    uuid: user.minecraft_uuid,
                    username: user.minecraft_username,
                    skin_url: user.current_skin_url,
                    skin_model: user.skin_model,
                    head_url: user.minecraft_uuid ? `https://crafatar.com/heads/${user.minecraft_uuid}?size=64&overlay` : null,
                    avatar_url: user.minecraft_uuid ? `https://crafatar.com/avatars/${user.minecraft_uuid}?size=128&overlay` : null,
                    render_url: user.minecraft_uuid ? `https://crafatar.com/renders/body/${user.minecraft_uuid}?size=256&overlay` : null
                }
            }
        });

    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è:', error);
        res.status(500).json({
            success: false,
            message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'
        });
    }
});

// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞
router.get('/verify', authenticateToken, (req, res) => {
    res.json({
        success: true,
        message: '–¢–æ–∫–µ–Ω –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω',
        user: {
            id: req.user.id,
            username: req.user.username,
            email: req.user.email
        }
    });
});

export default router; 