import express from 'express';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import { body, validationResult } from 'express-validator';
import { 
    userQueries, 
    sessionQueries,
    profileQueries
} from '../database/database.js';

const router = express.Router();

const JWT_SECRET = process.env.JWT_SECRET || 'dino-secret-key';
const SALT_ROUNDS = 12;
const TOKEN_EXPIRES_IN = '7d';

export const authenticateToken = async (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

    if (!token) {
        return res.status(401).json({ 
            success: false, 
            message: '–¢–æ–∫–µ–Ω –¥–æ—Å—Ç—É–ø–∞ –Ω–µ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª–µ–Ω' 
        });
    }

    try {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–æ–∫–µ–Ω –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
        const session = await sessionQueries.findByToken(token);
        if (!session) {
            return res.status(403).json({ 
                success: false, 
                message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' 
            });
        }

        // –í–µ—Ä–∏—Ñ–∏—Ü–∏—Ä—É–µ–º JWT
        const decoded = jwt.verify(token, JWT_SECRET);
        const user = await userQueries.findById(decoded.userId);
        
        if (!user) {
            return res.status(403).json({ 
                success: false, 
                message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω' 
            });
        }

        req.user = user;
        next();
    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Ç–æ–∫–µ–Ω–∞:', error);
        return res.status(403).json({ 
            success: false, 
            message: '–ù–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π —Ç–æ–∫–µ–Ω' 
        });
    }
};

// –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
const registerValidation = [
    body('username')
        .isLength({ min: 3, max: 20 })
        .withMessage('–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –æ—Ç 3 –¥–æ 20 —Å–∏–º–≤–æ–ª–æ–≤')
        .matches(/^[a-zA-Z0-9_]+$/)
        .withMessage('–ò–º—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –º–æ–∂–µ—Ç —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Ç–æ–ª—å–∫–æ –±—É–∫–≤—ã, —Ü–∏—Ñ—Ä—ã –∏ –ø–æ–¥—á–µ—Ä–∫–∏–≤–∞–Ω–∏—è'),
    
    body('email')
        .isEmail()
        .withMessage('–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π email')
        .normalizeEmail(),
    
    body('password')
        .isLength({ min: 1 })
        .withMessage('–ü–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω')
];

// –í–∞–ª–∏–¥–∞—Ü–∏—è –¥–ª—è –≤—Ö–æ–¥–∞
const loginValidation = [
    body('login')
        .notEmpty()
        .withMessage('–í–≤–µ–¥–∏—Ç–µ email –∏–ª–∏ –Ω–∏–∫–Ω–µ–π–º'),
    
    body('password')
        .notEmpty()
        .withMessage('–ü–∞—Ä–æ–ª—å –æ–±—è–∑–∞—Ç–µ–ª–µ–Ω')
];

// –†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è
router.post('/register', registerValidation, async (req, res) => {
    try {
        console.log('üìù Register attempt:', req.body);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–∞—Ü–∏—é
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            console.log('‚ùå Register validation errors:', errors.array());
            return res.status(400).json({
                success: false,
                message: '–û—à–∏–±–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏',
                errors: errors.array()
            });
        }

        const { username, email, password } = req.body;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å email
        const existingUserByEmail = await userQueries.findByEmail(email);
        if (existingUserByEmail) {
            return res.status(400).json({
                success: false,
                message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'
            });
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç—å username
        const existingUserByUsername = await userQueries.findByUsername(username);
        if (existingUserByUsername) {
            return res.status(400).json({
                success: false,
                message: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —Å —Ç–∞–∫–∏–º –∏–º–µ–Ω–µ–º —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç'
            });
        }

        // –°–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–ø–∞—Ä–æ–ª—å –±—É–¥–µ—Ç –∑–∞—Ö–µ—à–∏—Ä–æ–≤–∞–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤ –º–æ–¥–µ–ª–∏)
        const user = await userQueries.create(username, email, password);

        // –°–æ–∑–¥–∞–µ–º –ø—Ä–æ—Ñ–∏–ª—å –¥–ª—è –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        await profileQueries.createProfile(user.id, {
            level: 1,
            rating: 1000,
            avatar: 'avatars/photo_2025-07-03_02-50-32.jpg',
            title: '–ù–æ–≤–∏—á–æ–∫ XO Online'
        });

        // –°–æ–∑–¥–∞–µ–º JWT —Ç–æ–∫–µ–Ω
        const token = jwt.sign(
            { userId: user.id, username: user.username },
            JWT_SECRET,
            { expiresIn: TOKEN_EXPIRES_IN }
        );

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–µ—Å—Å–∏—é –≤ –±–∞–∑–µ
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + 7); // 7 –¥–Ω–µ–π
        await sessionQueries.create(user.id, token, expiresAt.toISOString());

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –æ–Ω–ª–∞–π–Ω
        await userQueries.updateOnlineStatus(user.id, true);

        res.status(201).json({
            success: true,
            message: '–†–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞',
            user: {
                id: user.id,
                username: user.username,
                email: user.email
            },
            token
        });

    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏:', error);
        res.status(500).json({
            success: false,
            message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'
        });
    }
});

// –í—Ö–æ–¥
router.post('/login', loginValidation, async (req, res) => {
    try {
        console.log('üîê Login attempt:', req.body);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤–∞–ª–∏–¥–∞—Ü–∏—é
        const errors = validationResult(req);
        if (!errors.isEmpty()) {
            console.log('‚ùå Validation errors:', errors.array());
            return res.status(400).json({
                success: false,
                message: '–û—à–∏–±–∫–∏ –≤–∞–ª–∏–¥–∞—Ü–∏–∏',
                errors: errors.array()
            });
        }

        const { login, password } = req.body;
        console.log('üîç Looking for user:', login);
        console.log('üîç Input password:', password);

        // –ù–∞—Ö–æ–¥–∏–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ email –∏–ª–∏ username
        let user = await userQueries.findByEmail(login);
        if (!user) {
            user = await userQueries.findByUsername(login);
        }
        
        if (!user) {
            console.log('‚ùå User not found:', login);
            return res.status(400).json({
                success: false,
                message: '–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å'
            });
        }
        
        console.log('üü¢ User found:', user.username);
        console.log('üîë Password hash from DB:', user.password_hash ? 'exists' : 'missing');
        console.log('üîç Hash length:', user.password_hash ? user.password_hash.length : 'null');

        // –í–†–ï–ú–ï–ù–ù–ê–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê - —Å–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–π —Ö–µ—à
        const testHash = await bcrypt.hash(password, 12);
        console.log('üß™ Test hash for current password:', testHash);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞—Ä–æ–ª—å
        console.log('üîç Input password length:', password.length);
        console.log('üîç Stored hash length:', user.password_hash ? user.password_hash.length : 'null');
        
        const isPasswordValid = await bcrypt.compare(password, user.password_hash);
        console.log('üîê Password validation result:', isPasswordValid);
        
        // –í–†–ï–ú–ï–ù–ù–ê–Ø –î–ò–ê–ì–ù–û–°–¢–ò–ö–ê - –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä—è–º–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ
        if (!isPasswordValid) {
            console.log('‚ùå Password validation failed for user:', user.username);
            console.log('‚ùå Input password:', password);
            console.log('‚ùå Hash from DB:', user.password_hash);
            
            // –í–†–ï–ú–ï–ù–ù–û–ï –†–ï–®–ï–ù–ò–ï: –µ—Å–ª–∏ –ø–∞—Ä–æ–ª—å —Ä–∞–≤–µ–Ω –ø—Ä–æ—Å—Ç–æ–º—É —Ç–µ–∫—Å—Ç—É
            if (password === user.password_hash) {
                console.log('üö® FOUND ISSUE: Password stored as plain text!');
                console.log('üîß Fixing by updating hash...');
                
                // –û–±–Ω–æ–≤–ª—è–µ–º –ø–∞—Ä–æ–ª—å —Å –ø—Ä–∞–≤–∏–ª—å–Ω—ã–º —Ö–µ—à–µ–º
                const newHash = await bcrypt.hash(password, 12);
                await userQueries.updatePassword(user.id, newHash);
                console.log('‚úÖ Password hash updated');
            } else {
                return res.status(400).json({
                    success: false,
                    message: '–ù–µ–≤–µ—Ä–Ω—ã–π –ª–æ–≥–∏–Ω –∏–ª–∏ –ø–∞—Ä–æ–ª—å'
                });
            }
        }

        // –°–æ–∑–¥–∞–µ–º JWT —Ç–æ–∫–µ–Ω
        const token = jwt.sign(
            { userId: user.id, username: user.username },
            JWT_SECRET,
            { expiresIn: TOKEN_EXPIRES_IN }
        );

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å–µ—Å—Å–∏—é –≤ –±–∞–∑–µ
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + 7); // 7 –¥–Ω–µ–π
        await sessionQueries.create(user.id, token, expiresAt.toISOString());

        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –æ–Ω–ª–∞–π–Ω
        await userQueries.updateOnlineStatus(user.id, true);



        res.json({
            success: true,
            message: '–í—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ',
            user: {
                id: user.id,
                username: user.username,
                email: user.email,

            },
            token
        });

    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –≤—Ö–æ–¥–∞:', error);
        res.status(500).json({
            success: false,
            message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'
        });
    }
});

// –í—ã—Ö–æ–¥
router.post('/logout', authenticateToken, async (req, res) => {
    try {
        const authHeader = req.headers['authorization'];
        const token = authHeader && authHeader.split(' ')[1];

        // –£–¥–∞–ª—è–µ–º —Å–µ—Å—Å–∏—é –∏–∑ –±–∞–∑—ã
        await sessionQueries.delete(token);
        
        // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Å—Ç–∞—Ç—É—Å –æ—Ñ—Ñ–ª–∞–π–Ω
        await userQueries.updateOnlineStatus(req.user.id, false);



        res.json({
            success: true,
            message: '–í—ã—Ö–æ–¥ –≤—ã–ø–æ–ª–Ω–µ–Ω —É—Å–ø–µ—à–Ω–æ'
        });

    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –≤—ã—Ö–æ–¥–∞:', error);
        res.status(500).json({
            success: false,
            message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'
        });
    }
});

router.get('/profile', authenticateToken, async (req, res) => {
    try {
        const user = await userQueries.findById(req.user.id);
        
        res.json({
            success: true,
            user: {
                id: user.id,
                username: user.username,
                email: user.email,
                avatar_url: user.avatar_url,
                created_at: user.created_at,
                last_login: user.last_login,

            }
        });

    } catch (error) {
        console.error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø—Ä–æ—Ñ–∏–ª—è:', error);
        res.status(500).json({
            success: false,
            message: '–í–Ω—É—Ç—Ä–µ–Ω–Ω—è—è –æ—à–∏–±–∫–∞ —Å–µ—Ä–≤–µ—Ä–∞'
        });
    }
});

// –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ç–æ–∫–µ–Ω–∞
router.get('/verify', authenticateToken, (req, res) => {
    res.json({
        success: true,
        message: '–¢–æ–∫–µ–Ω –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω',
        user: {
            id: req.user.id,
            username: req.user.username,
            email: req.user.email
        }
    });
});



export default router; 